<!DOCTYPE html>
<html>
<head>
<title>Chained Experiments</title>
<meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
<meta content='sinatra, ruby, nginx, redis, nanoc, nanoc3, github, blog, monitoring, metrics, collectd' name='keywords'>
<link href='/assets/css/pygment.css' media='screen' rel='stylesheet' type='text/css'>
<link href='/assets/css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script src='/assets/js/jquery-1.6.min.js' type='text/javascript'></script>
<script src='/assets/js/humane.js' type='text/javascript'></script>
<script src='/assets/js/app.js' type='text/javascript'></script>
<script src='/assets/js/disqus.js' type='text/javascript'></script>
<link href='http://feeds.feedburner.com/schmurfy' rel='alternate' title='schmurfy.github.com' type='application/atom+xml'>
<link href='http://fonts.googleapis.com/css?family=Expletus+Sans:700' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif' rel='stylesheet' type='text/css'>
<script>
  //<![CDATA[
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-23121021-1']);
    _gaq.push(['_trackPageview']);
    
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  //]]>
</script>


</head>
<body>
<div id='page'>
<div id='inner-page'>
<a class='fork_me' href='http://github.com/schmurfy'>
<img alt='Fork me on GitHub' src='https://d3nwyuy0nl342s.cloudfront.net/img/e6bef7a091f5f3138b8cd40bc3e114258dd68ddf/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67'>
</a>
<div id='header'>
<h1 class='blog_title'>
<a href='/'>Chained experiments</a>
</h1>
</div>
<div id='content'>
<div class="article">
<div class="article_date date" title="2011-05-19T20:30:00Z">May 19, 2011</div>
<h1 class="title">
<a href="/2011/05/07/ruby_application_monitoring.html">Ruby Application Monitoring</a>
</h1>
<div class="tags">
<a href="/tags/collectd/" class="tag">collectd</a>, <a href="/tags/metrics/" class="tag">metrics</a>, <a href="/tags/monitoring/" class="tag">monitoring</a>, <a href="/tags/ruby/" class="tag">ruby</a>
</div>
<div class="body">
<p>When any of your applications starts to really fly by themselves you are bound to reach a
point where you want/need to know what happen inside it and translate that into graphs
you can show and monitor to check the health of the system.</p>

<p>Such a system include many parts that must work together to bring you the data you want
and/or want to show and that is where I faced my first wall.</p>

<h2>What are those parts ?</h2>

<h3>Producer</h3>

<p>Your applications can produce data you want to store and view immediately or later,
a general purpose probe can also extract useful metrics from a physical server like
the cpu usage, the load, memory, etc...<br></p>

<h3>Aggregator / Router</h3>

<p>This node is the one receiving the data and deciding what to do with them, whether
it will be stored on a local disk in rrd or send on the network to another application
and whether to use the data as is or to transform them before.<br></p>

<h3>Storage Engine</h3>

<p>I decided to separate this one but most of the time it will be a subpart of the
Aggregator / Router. The storage will determine how and where your data will be
stored, most of the time it will be rrd since it works and there are not real
alternatives out there.<br>
While the rrd format itself is nice I am not really too fond of the rrd library
itself, the api is really ugly and always force me to do things I do not want
to do whenever I need to work with it.</p>

<h3>Graph drawer</h3>

<p>That is the last part and will surely be the most important since whatever
energy/dedication you put in setting up the other parts it is that one anyone
will face and that is also one of my biggest problem...</p>

<h2>Choosing the right parts</h2>

<p>There are some beast out there that are heavily used when you start speaking about monitoring
you are nearly forced to hit them (or get it by them), the name I hear the most are:
Nagios, Munin, Cacti, MRTG, SmokePing.</p>

<p>There a multiple problems for me with those systems, the first one is that some
are more or less focused on a specific need (like SmokePing) and making them play
together can be really "fun", the kind of fun nobody wants.<br>
The other problem I faced is that they tend to want control over the whole monitoring system,
they want you to use their producers module, their graph drawer, their router and if
you want to step aside and change one part your are doomed.<br>
It may have changed since last time I did a check but I highly doubt it.</p>

<p>I worked with some of those in the past but never really liked them so when I
faced again the need to collect metrics from different applications/languages
as well as server's metrics I tried to find something else.</p>

<h3>The SmokePing case</h3>

<p>Before I started working on a monitoring solution for a work project I am currently
on there was previously SmokePing set up, I may be heavily biased on it
because of my first impression but what first impression it madeÂ !</p>

<p>The first things I noticed when looking at it was that the server part was slow as hell
and was taking a more than noticeable part of the cpu (I honestly do not
remember how much but it was certainly not invisible on the machine speaking
of resources) so I checked its producer counterpart which is on an embedded system
(Soekris hardware) and here too the daemon was not invisible at all !</p>

<p>The last thing that crushed that beast for me is that loading a page with graphs on
it was slow too and caused cpu spikes, perfect !</p>

<p>It is perfectly possible that smokeping was badly installed and would work
far better in normal conditions (that said I am not too sure about the producer part)
but seriously what can you do with such bright first impression ?</p>

<h3>Enter Collectd</h3>

<p>While looking for a decent Aggregator I came upon collectd which I never saw
before and does a really great job at dispatching metrics.</p>

<p>Collectd is a modular application with modules falling in two categories:</p>

<ul>
<li><p>readers: these plugins receive data from somewhere or extract it (ex: 
network, shell command, /proc file, etc...)</p></li>
<li><p>writers: these plugins will output the data somewhere (ex: network again,
rrdtool, rrdcached, database, etc...)</p></li>
</ul>
<p>Collectd do a really nice job but some parts are hard to use and not really
designed for usability, the best example I have is the filter system,
Collectd comes with a really powerful filter subsystem which lets you
update/add/delete fields of the collectd "messages" or the whole messages.</p>

<p>Sadly this filter subsystem has one of the worst configuration interface
I have seen until now, see for yourself (and this one is a simple one):</p>

<pre><div class="highlight"><pre><span class="nt">&lt;Rule</span> <span class="s">"ping_server1"</span><span class="nt">&gt;</span>&#x000A;  <span class="nt">&lt;Match</span> <span class="s">"regex"</span><span class="nt">&gt;</span>&#x000A;    <span class="nb">Plugin</span> <span class="s2">"^ping$"</span>&#x000A;    <span class="nb">TypeInstance</span> <span class="s2">"^1.2.3.4$"</span>&#x000A;  <span class="nt">&lt;/Match&gt;</span>&#x000A;  <span class="nt">&lt;Target</span> <span class="s">"replace"</span><span class="nt">&gt;</span>&#x000A;    <span class="nb">TypeInstance</span> <span class="s2">"1.2.3.4"</span> <span class="s2">"server1"</span>&#x000A;  <span class="nt">&lt;/Target&gt;</span>&#x000A;<span class="nt">&lt;/Rule&gt;</span></pre></div>
</pre>

<p>This one is pretty straight forward but all this text is just to
replace a string with another...</p>

<p>In another language this could become:</p>

<pre><div class="highlight"><pre><span class="k">if</span> <span class="nb">p</span><span class="o">.</span><span class="n">type_instance</span> <span class="o">==</span> <span class="s2">"1.2.3.4"</span>&#x000A;  <span class="nb">p</span><span class="o">.</span><span class="n">type_instance</span> <span class="o">=</span> <span class="s2">"server1"</span>&#x000A;<span class="k">end</span></pre></div>
</pre>

<p>Just imagine what a complex flow would look with the xml like
syntax :/</p>

<p>While I have some issues with collectd I am currently using it on
production servers as well as embedded systems and it works well.</p>

<h3>The producers</h3>

<p>Sending your own counters to collectd is not really hard, the network
plugin of collectd use a clearly defined and simple binary format served
over UDP and many libraries exist out there for different languages to
generate those packets and send them to collectd.</p>

<h3>Serving graphs</h3>

<p>The only part left is the user interface used to navigate and generate
the graphs from all these data we collected and that is where the real
problem arise... Since many existing systems want control over the
whole data collection chains you cannot easily integrate data from
somewhere else.</p>

<p>My quest was to find a tool doing a really simple thing (at least
I thought it was): draw graphs from rrd file and serve them to the
clients while staying nearly invisible on the server resource wise.</p>

<p>Do you know one ? Because I could really use some names here.</p>

<p>I ended up coding my own modest graph drawer but that is just a small
part of what I need. WHat I have now is a sinatra application
which uses the client itself to compute the graphs with some
javascript around the excellent jquery library: <a href="http://code.google.com/p/flot/">flot</a>.</p>

<p>Since the clients are drawing the graphs the server is really
not doing much, only extracting data from the rrd and formatting
them in json which is really nice.</p>

<h2>Current State</h2>

<p>I have a working stack for now, I am not completly happy with it
but at least I have control over the parts and except for the grapher
I am just using existing application/library so I did not have
to write any code.</p>

<p>I am still searching for a better solutions and working on some
projects which may help but that will be for another time :)</p>
<a data-disqus-identifier="2011/05/19 22:30" href="/2011/05/07/ruby_application_monitoring.html#disqus_thread">Comments</a>
</div>
</div>

<div class="article">
<div class="article_date date" title="2011-05-06T13:00:00Z">May 06, 2011</div>
<h1 class="title">
<a href="/2011/05/06/create_your_github_user_page_with_nanoc.html">Create your Github user page with nanoc</a>
</h1>
<div class="tags">
<a href="/tags/blog/" class="tag">blog</a>, <a href="/tags/github/" class="tag">github</a>, <a href="/tags/nanoc/" class="tag">nanoc</a>, <a href="/tags/nanoc3/" class="tag">nanoc3</a>, <a href="/tags/ruby/" class="tag">ruby</a>
</div>
<div class="body">
<p>I finally took the time to build myself a fully featured blog and start writing down things that floats
in my head both for me and for anyone it can help.<br>
I was sure of one thing: I wanted a static blog, I do not want having to learn to use a complex
admin interface that would certainly not fit me needs and end with a fork to maintain...<br>
Another reason is that I prefer to edit posts in my favorite text editor (that would be textmate)
than editing it online with a pale copy of a real text editor.</p>

<p>I was looking at github user pages for quite some time but the quick look I gave to jekyll did not convinced
me so here is an alternative way to build your github user page without using jekyll.</p>

<h2>What we will use</h2>

<p>Nanoc is a powerful ruby static website generator, I already used it before for a personal documentation
repository (something like my personal knowledge database) and tested the alternatives before settling on
it so there was little to no reason to switch except if a new alternative with more features had appeared
but jekyll is certainly not that.</p>

<p>So nanoc it is !<br></p>

<p>This article will not teach you how to use nanoc by itself, if you are interested in it you can check:</p>

<ul>
<li><a href="http://nanoc.stoneship.org/">The Official Website</a></li>
<li><a href="https://github.com/mgutz/nanoc3_blog">The template I based mine on</a></li>
<li><a href="https://github.com/schmurfy/schmurfy.github.com/tree/source">And obviously my template</a></li>
</ul>
<h2>How github user's pages work</h2>

<p>The user page system is really simple to use and works really well, what they did is that if you create a repository
with a special name (<code>&lt;user&gt;</code>.github.com) then anything pushed in the master branch will be available at the
same address, pretty neat and effective !</p>

<p>The master branch can either contains raw html/css/... documents or a jekyll project which will be
used to generate the html so in our case we want to push the resulting output from nanoc.</p>

<h2>Workspace organization</h2>

<p>What I did is use another branch than master to host the actual nanoc application and push the
resulting html in the master branch, here is how I organized my workspace:</p>

<div class="highlight"><pre>root <span class="o">[</span> -&gt; <span class="s2">"source"</span> <span class="o">]</span>&#x000A;  |- content <span class="o">(</span>nanoc templates<span class="o">)</span>&#x000A;  |- layouts <span class="o">(</span>nanoc layouts<span class="o">)</span>&#x000A;  |- lib <span class="o">(</span>ruby files extending nanoc<span class="o">)</span>&#x000A;  |- output <span class="o">[</span> -&gt; <span class="s2">"master"</span> <span class="o">]</span>&#x000A;  </pre></div>


<p>root will contains a working copy of our git repository pointing at the source branch and
output will contains a working copy of the same repository pointing at the master branch,
the tricky part here is that these two branches need to be completly separated,
we wil now see how (there is a guide on github to do this too).</p>

<h2>Setting up things</h2>

<p>First we need to initialize the repository, just use your root folder for this
("$" is the prompt here):</p>

<div class="highlight"><pre><span class="c"># initialize the local repository</span>&#x000A;  <span class="nv">$ </span>git init&#x000A;<span class="c"># commits your files</span>&#x000A;  <span class="nv">$ </span>git add .&#x000A;  <span class="nv">$ </span>git ci -m <span class="s2">"init"</span> </pre></div>


<p>Now we have a master branch containing our site's source which is not yet what we
want, so we will now rename this branch and push it to the remote:</p>

<div class="highlight"><pre><span class="c"># rename our master branch</span>&#x000A;  <span class="nv">$ </span>git br -m master <span class="nb">source</span>&#x000A;<span class="c"># add your github repository as origin</span>&#x000A;  <span class="nv">$ </span>git add origin git@github.com:<span class="o">[</span>user<span class="o">]</span>/<span class="o">[</span>user<span class="o">]</span>.github.com.git&#x000A;<span class="c"># push to the remote repository and set the master local branch to</span>&#x000A;<span class="c"># track origin/master</span>&#x000A;  <span class="nv">$ </span>git push -u origin master</pre></div>


<p>We have a repository with only one branch: source, now we can create the master branch.<br>
remove the output folder if it exists (rm -rf output) and do this:</p>

<div class="highlight"><pre><span class="c"># fetch a working copy of your repository</span>&#x000A;  <span class="nv">$ </span>git clone git@github.com:<span class="o">[</span>user<span class="o">]</span>/<span class="o">[</span>user<span class="o">]</span>.github.com.git output&#x000A;  <span class="nv">$ </span><span class="nb">cd </span>output&#x000A;<span class="c"># create the isolated branch</span>&#x000A;  <span class="nv">$ </span>git symbolic-ref HEAD refs/heads/master&#x000A;  <span class="nv">$ </span>rm .git/index&#x000A;  <span class="nv">$ </span>git clean -fdx</pre></div>


<p>You should now have your master branch ready, just generate your nanoc output
(nanoc3 co in the root folder) and commit &amp; push your files and your site should
appears shortly.</p>

<p>(Actually it took a second commit for me for the site to effectively appears)</p>

<p>One thing allowing this setup to work is that nanoc do not delete the output folder
when rebuilding the site, it justs overwrite existing files.</p>
<a data-disqus-identifier="2011/05/06 15:00" href="/2011/05/06/create_your_github_user_page_with_nanoc.html#disqus_thread">Comments</a>
</div>
</div>

<div class="article">
<div class="article_date date" title="2011-05-03T20:00:00Z">May 03, 2011</div>
<h1 class="title">
<a href="/2011/05/03/simple_yet_secure_file_server.html">Simple yet secure file server</a>
</h1>
<div class="tags">
<a href="/tags/nginx/" class="tag">nginx</a>, <a href="/tags/redis/" class="tag">redis</a>, <a href="/tags/ruby/" class="tag">ruby</a>, <a href="/tags/sinatra/" class="tag">sinatra</a>
</div>
<div class="body">
<p>This is a problem I faced many times but did not had the opportunity to find a good approach to the problem,
recently I faced it once again and found what i consider a really nice way to implement it efficiently and securely.</p>

<h2>The problem</h2>

<p>The problem is quite simple to describe: how can you serve a file to a given client without allowing it full
access to the repository, and serves it fast and efficiently resources wise.</p>

<h2>My environment</h2>

<p>Here are some background on my environment to better understand why I did things that way: The application I work
on is already made of multiple distinct ruby servers/daemons speaking to each other using an in house network protocol,
aside of those I already have a redis server used mostly for caching data.</p>

<h2>Let's get to work !</h2>

<p>Among time I tried different solutions to this problem:</p>

<h3>The worst method</h3>

<p>You set up a webserver to serve a defined folder where all your files are
  and your disable the autoindex feature.</p>

<p>The problems are:</p>

<ul>
<li>if someone have he link it can download again the file whenever he wants
(it may or may not be a problem depending on your usage)</li>
<li>a client with the link can pass it to anyone to download the file</li>
<li>a client may guess another file's path and download it</li>
</ul>
<p>The last time I used this method the filenames were alphanumeric strings
  of 32 characters, this at least reduce the guessing risk to nearly zero</p>

<h3>The second, slightly better</h3>

<p>We now have a web application (php, ruby, perl, etc...) which serves the pages
  to the clients, the files are stored on the disk outside the webserver root and so, are not
  accessible directly by clients.</p>

<p>The application authenticate the client (how it is done is irrelevant here) and then the
  application sends the file's content itself to the client.</p>

<p>The problems:</p>

<ul>
<li>You monopolize one instance of your application for this task (it is
especially a problem with ruby on rails)</li>
<li>chances are that streaming the file through your application will slow down
the transfer speed and it can takes more resources on the server.</li>
</ul>
<p>At least with this approach a client can no longer access a file we don't want him
  to download and even if he manages to guess another file's name he will just be rejected.</p>

<p>Clients can still exchanges login/pass but that's another story, let's consider that our
  clients here do not share passwords.</p>

<h3>Now we talk</h3>

<p>I know this is not a terribly big news but apache have support for sending files directly
  to a client when asked by an application running below it, when an application returns
  an header "X-Sendfile" pointing to an absolute path on the webserver disk then this file
  will be streamed by apache to the client.</p>

<p>Nginx has a similar feature but it works differently, here is an example config file:</p>

<div class="highlight"><pre><span class="k">server</span> <span class="p">{</span>&#x000A;  <span class="kn">listen</span> <span class="mi">3000</span><span class="p">;</span>&#x000A;&#x000A;  <span class="kn">location</span> <span class="s">/</span> <span class="p">{</span>&#x000A;    <span class="kn">root</span> <span class="s">'[...]/public'</span><span class="p">;</span>&#x000A;&#x000A;    <span class="kn">passenger_enabled</span> <span class="no">on</span><span class="p">;</span>&#x000A;    <span class="kn">passenger_min_instances</span> <span class="mi">1</span><span class="p">;</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="kn">location</span> <span class="s">"/data"</span> <span class="p">{</span>&#x000A;    <span class="kn">internal</span><span class="p">;</span>&#x000A;    <span class="kn">root</span> <span class="s">"/path/to/data"</span><span class="p">;</span>&#x000A;  <span class="p">}</span>&#x000A;<span class="p">}</span></pre></div>

  

<p>We have a sinatra application running under passenger on port 3000 and we declare
  an internal location where our files are, the /data path will not be accessible
  for web clients.</p>

<p>Now the next part is to send the required headers, here is what a minimal sinatra
  application looks like for doing this:
</p>
<div class="highlight"><pre><span class="nb">require</span> <span class="s1">'rubygems'</span>&#x000A;<span class="nb">require</span> <span class="s1">'sinatra'</span>&#x000A;&#x000A;<span class="n">get</span> <span class="s2">"/:token/*"</span> <span class="k">do</span>&#x000A;  <span class="c1"># we use splat here to allow the path to include "/"</span>&#x000A;  <span class="n">path</span> <span class="o">=</span> <span class="n">params</span><span class="o">[</span><span class="ss">:splat</span><span class="o">].</span><span class="n">join</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>&#x000A;  <span class="n">content_type</span> <span class="s1">'application/x-zip'</span>&#x000A;&#x000A;<span class="n">headers</span><span class="p">(</span>&#x000A;      <span class="c1"># Set the filename for the browser, you can force it</span>&#x000A;      <span class="c1"># or just use the original one ( File.basename(path) )</span>&#x000A;      <span class="s2">"Content-Disposition"</span> <span class="o">=&gt;</span> <span class="s2">"attachment; filename="</span><span class="n">file</span><span class="o">.</span><span class="n">txt</span><span class="s2">""</span><span class="p">,</span>&#x000A;&#x000A;  <span class="c1"># and ask nginx to send this file to the client</span>&#x000A;  <span class="s2">"X-Accel-Redirect"</span> <span class="o">=&gt;</span> <span class="s2">"/data/</span><span class="si">#{</span><span class="n">path</span><span class="si">}</span><span class="s2">"</span>&#x000A;<span class="p">)</span>&#x000A;&#x000A;&#x000A;<span class="c1"># finally return an empty body</span>&#x000A;  <span class="k">return</span> <span class="s2">""</span>&#x000A;<span class="k">end</span></pre></div>


<p>This is a minimal application, no authentication, no security check.
  Now if we want a full application we need some kind of strategy to ensure the client
  have access to the file he asked, I did this by using redis:</p>

<p>When a client wants a file he first needs to ask our main application (this is
  the one he is connected to), this application will respond with a token and a path (
  the token is saved in the redis database and set to expire in a fixed delay),
  the client will then ask the file server for this file with the token just received,
  here is the complete sinatra application:</p>

<div class="highlight"><pre><span class="nb">require</span> <span class="s1">'rubygems'</span>&#x000A;<span class="nb">require</span> <span class="s1">'sinatra'</span>&#x000A;<span class="nb">require</span> <span class="s1">'redis'</span>&#x000A;&#x000A;&#x000A;<span class="n">get</span> <span class="s2">"/:token/*"</span> <span class="k">do</span>&#x000A;  <span class="c1"># Connect to the redis database</span>&#x000A;  <span class="n">redis</span> <span class="o">=</span> <span class="no">Redis</span><span class="o">.</span><span class="n">new</span>&#x000A;  <span class="c1"># check the specified token</span>&#x000A;  <span class="n">allowed_path</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"file_download:</span><span class="si">#{</span><span class="n">params</span><span class="o">[</span><span class="ss">:token</span><span class="o">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>&#x000A;  <span class="n">path</span> <span class="o">=</span> <span class="n">params</span><span class="o">[</span><span class="ss">:splat</span><span class="o">].</span><span class="n">join</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>&#x000A;&#x000A;  <span class="c1"># only only passage if the token exists and the path asked</span>&#x000A;  <span class="c1"># is the same as the one associated with the token in redis</span>&#x000A;  <span class="k">if</span> <span class="n">path</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">allowed_path</span> <span class="o">==</span> <span class="n">path</span><span class="p">)</span>&#x000A;    <span class="c1"># set the content type so the browser reacts as expected</span>&#x000A;    <span class="n">content_type</span> <span class="s1">'xxx/yyy'</span>&#x000A;&#x000A;    <span class="n">headers</span><span class="p">(</span>&#x000A;        <span class="s2">"Content-Disposition"</span> <span class="o">=&gt;</span> <span class="sx">%{attachment; filename="file.ext"}</span><span class="p">,</span>&#x000A;        <span class="s2">"X-Accel-Redirect"</span> <span class="o">=&gt;</span> <span class="s2">"/data/</span><span class="si">#{</span><span class="n">path</span><span class="si">}</span><span class="s2">"</span>&#x000A;      <span class="p">)</span>&#x000A;    <span class="k">return</span> <span class="s2">""</span>&#x000A;  <span class="k">else</span>&#x000A;    <span class="c1"># return a 404 if access is refused</span>&#x000A;    <span class="c1"># so the client have no way to tells if access was refused</span>&#x000A;    <span class="c1"># or the file really does not exists</span>&#x000A;    <span class="k">raise</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">NotFound</span>&#x000A;  <span class="k">end</span>&#x000A;<span class="k">end</span>  </pre></div>

  

<p>Since the keys in redis have an expiration delay the client is only allowed to
  access the file once and has to make another request to download it again.</p>

<p>The expiration delay can even be really short since the check is done at the
  start of the download, having a too short delay may cause more problems though
  if the client need to retry the download for any reason.</p>

<h2>Conclusion</h2>

<p>Thanks to redis (it would also work with any database actually) you can distribute the
  roles between your applications as you wish and with the configuration shown above any
  application in your environment could deliver a pass to access a given file allowing
  them to share a single "file server" and still maintaining tight access control.</p>

<p>Following the same idea we could also register a number of allowed downloads in redis
  and decrement the counter each time the url is accessed, the atomic nature of redis
  operations makes this really easy to do.</p>
<a data-disqus-identifier="2011/05/03 22:00" href="/2011/05/03/simple_yet_secure_file_server.html#disqus_thread">Comments</a>
</div>
</div>
<div class='clear'></div>
</div>
<div id='sidebox'>
<h2>General</h2>
<ul>
<!-- %li -->
<!-- %a{:href => "/about.html"} About -->
<li>
<a href='http://feeds.feedburner.com/schmurfy'>RSS Feed</a>
</li>
</ul>
<!-- %h2 Projects -->
<!-- %ul -->
<!-- %li -->
<!-- %a{:href => "/projects/drone.html"} Drone -->
<h2>Recent posts</h2>
<ul>
<li>
<a href='/2011/05/07/ruby_application_monitoring.html' title='Full article'>Ruby Application Monitoring</a>
</li>
<li>
<a href='/2011/05/06/create_your_github_user_page_with_nanoc.html' title='Full article'>Create your Github user page with nanoc</a>
</li>
<li>
<a href='/2011/05/03/simple_yet_secure_file_server.html' title='Full article'>Simple yet secure file server</a>
</li>
</ul>
<h2>Tags</h2>
<ul>
<li>
<a href='/tags/ruby/'>ruby</a>
(3)
</li>
<li>
<a href='/tags/nanoc3/'>nanoc3</a>
(1)
</li>
<li>
<a href='/tags/nginx/'>nginx</a>
(1)
</li>
<li>
<a href='/tags/redis/'>redis</a>
(1)
</li>
<li>
<a href='/tags/nanoc/'>nanoc</a>
(1)
</li>
<li>
<a href='/tags/sinatra/'>sinatra</a>
(1)
</li>
<li>
<a href='/tags/github/'>github</a>
(1)
</li>
<li>
<a href='/tags/blog/'>blog</a>
(1)
</li>
<li>
<a href='/tags/monitoring/'>monitoring</a>
(1)
</li>
<li>
<a href='/tags/metrics/'>metrics</a>
(1)
</li>
<li>
<a href='/tags/collectd/'>collectd</a>
(1)
</li>
</ul>
<h2>Archives</h2>
<ul>
<li>
<a href='/archives.html'>All</a>
</li>
</ul>
</div>
</div>
</div>
<div id='footer'>
Content and Design Â© Julien Ammous
</div>
</body>
</html>
