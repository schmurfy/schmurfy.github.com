<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://schmurfy.github.com/</id>
  <title>Chained Experiments</title>
  <updated>2011-09-25T09:00:00Z</updated>
  <link rel="alternate" href="http://schmurfy.github.com/"/>
  <link rel="self" href="http://schmurfy.github.com/atom.xml"/>
  <author>
    <name>Julien Ammous</name>
    <uri>http://schmurfy.github.com</uri>
  </author>
  <entry>
    <id>tag:schmurfy.github.com,2011-09-25:/2011/09/25/on_fibers_and_threads.html</id>
    <title type="html">On fibers and threads</title>
    <published>2011-09-25T09:00:00Z</published>
    <updated>2011-09-25T09:00:00Z</updated>
    <link rel="alternate" href="http://schmurfy.github.com/2011/09/25/on_fibers_and_threads.html"/>
    <content type="html">&lt;p&gt;Now that ruby 1.9 is gaining more attention and more and more people are saying goodbye to ruby 1.8 to
welcome ruby 1.9.2 (don't even try 1.9.1 the latest patch release does not even work correctly...)
they rediscover the new concurrency tool 1.9 gave us: the Fiber.&lt;/p&gt;

&lt;p&gt;So what is it all about and why can it be useful ?&lt;/p&gt;

&lt;h2&gt;Threads&lt;/h2&gt;

&lt;p&gt;First let's start with some facts about ruby 1.9 threads:&lt;/p&gt;

&lt;p&gt;Ruby threads are now mapped 1:1 with a native os threads, it may sounds great but not that much
because of the evil Global Interpreter Lock which guarantee only one thread will ever have the hand
so no real concurrency (in short the garbage collector was not designed to
handle multithreading so the GIL allows it to work).&lt;/p&gt;

&lt;p&gt;The problem is that while you not gain real concurrency you still have to deal with the pain
associated with threads in any language, specifically your thread can be put to sleep anytime
and another thread will start/continue its job.&lt;/p&gt;

&lt;p&gt;Here is an example of such behavior:&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'thread'&lt;/span&gt;

&lt;span class="no"&gt;MUTEX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Mutex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="no"&gt;MUTEX&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;synchronize&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;th1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;times&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="s2"&gt;"[Thread 1] Tick &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;


&lt;span class="n"&gt;th2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;times&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="s2"&gt;"[Thread 2] Tick &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;


&lt;span class="n"&gt;th1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;
&lt;span class="n"&gt;th2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;Just paste this code in a text file an execute it with ruby, what you will see depends on many factors but the sure
thing is that you will see tangled lines starting with Thread 1 and Thread 2 which means that none of thread did is
job in one go, here is the result on my computer (I only kept the context changes):&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;[Thread 1] Tick 0
[...]
[Thread 1] Tick 67
[Thread 2] Tick 0
[...]
[Thread 2] Tick 99
[Thread 1] Tick 70
[...]
[Thread 1] Tick 99
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;This example just use the standard input (and have to use a mutex to keep both threads to write at the same time) but imagine what it can be with concurrent database queries...&lt;/p&gt;

&lt;p&gt;I did not dug really far in ruby sources to see how threads are implemented so this explanation my
be slightly off but my understanding so far is that a ruby thread is given a fixed amount of time to do its
work, if in the given amount it is not finished the scheduler suspends it and wakeup another thread
waiting in the queue, it goes on and on until all threads are done or the program is stopped.&lt;/p&gt;

&lt;h2&gt;Fibers&lt;/h2&gt;

&lt;p&gt;So now that we saw what Threads had to offer let's talk about their counterpart: the Fiber, first
I want to say I have no idea how fibers are implemented but it does not change the validity of the following.&lt;/p&gt;

&lt;p&gt;You can think of fibers as threads without automatic scheduling, when a fiber is running nothing
else is, this is a core concept and a really important one indeed but we will talk more about this later,&lt;br&gt;
let's see an example before that:&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;fb1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Fiber&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;times&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="s2"&gt;"[Fiber 1] Tick &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;fb2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Fiber&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;times&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="s2"&gt;"[Fiber 2] Tick &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;fb1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resume&lt;/span&gt;
&lt;span class="n"&gt;fb2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resume&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;What I did was just convert the thread example from before to fibers, now the result is really different
and most importantly does not depends on external factors like threads do, when executing this example
here is what you will get on any machine:&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;[Fiber 1] Tick 0
[...]
[Fiber 1] Tick 99
[Fiber 2] Tick 0
[...]
[Fiber 2] Tick 99
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;When we called resume on the first fiber it started its job and completed it, then the next line was
executed and the second fiber was started and finished its job before the program completed, no
magic, no random, just what you wrote !&lt;/p&gt;

&lt;p&gt;Now there are things you should know about fibers, the power you have on them comes at a price:&lt;br&gt;
You need to be sure than none of your fiber will block the whole application, if you are making
a server doing heavy computation in ruby on each request you can forget fibers as only one client
will be served at once but if you are working on a server working with I/O typically the network and
one or more databases then you are good to go (with proper 1.9 drivers).&lt;/p&gt;

&lt;p&gt;There is also some calls to avoid in the standard library, the first to come to mind is "sleep",&lt;br&gt;
here is an example of the problem with it:&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'fiber'&lt;/span&gt;

&lt;span class="n"&gt;fb1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Fiber&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;"[Fiber 1] Started"&lt;/span&gt;
  &lt;span class="nb"&gt;sleep&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
  &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;"[Fiber 1] Completed"&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;fb2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Fiber&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;times&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;"[Fiber 2] tick &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;fb1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resume&lt;/span&gt;
&lt;span class="n"&gt;fb2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resume&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;This program will sleep 2 seconds and then output 10 times a message, we will see in the next section how EventMachine can help us with this specific case, here is the output for this one:&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;[Fiber 1] Started
[Fiber 1] Completed
[Fiber 2] tick 0
[...]
[Fiber 2] tick 9
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;h2&gt;EventMachine&lt;/h2&gt;

&lt;h3&gt;Short introduction&lt;/h3&gt;

&lt;p&gt;If you already know what EventMachine is you can jump to the next section.&lt;/p&gt;

&lt;p&gt;When you write a standard ruby application your program once executed will run from the start to the end in a linear way, now this is where EventMachine slightly change things: when you execute an EventMachine based ruby application you are no longer in charge of the "main loop" which is now C code, instead you register for events and do action based on those events.&lt;br&gt;
A simple example would be a console program: when you are waiting for user input the application is doing nothing and that would be where the EventMachine main loop is, then when a user type something a callback in your application is called with the text, after you handled it the EventMachine main loop takes back control.&lt;/p&gt;

&lt;h3&gt;How can it help us&lt;/h3&gt;

&lt;p&gt;Fibers power are best put to use in an asynchronous environment, in ruby we have the great EventMachine
but working in asynchronous mode is a real pain, here is an example from the em-http-request gem:&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'eventmachine'&lt;/span&gt;
&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'em-http-request'&lt;/span&gt;

&lt;span class="no"&gt;EM&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;http&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;EM&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;HttpRequest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'http://google.com/'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
      &lt;span class="ss"&gt;:query&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;'keyname'&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;'value'&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;

  &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;errback&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="s1"&gt;'Uh oh'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="no"&gt;EM&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;response_header&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;
    &lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;response_header&lt;/span&gt;
    &lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;

    &lt;span class="no"&gt;EM&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;"Done."&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;The callback and errback block you provide will be executed respectively when a result or an error arrives and the execution will continue so "Done." will be displayed before any of the two blocks.&lt;br&gt;
We can use Threads/Fibers to transform any asynchronous code path to match the  synchronous code path we are used to work with, here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'fiber'&lt;/span&gt;
&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'eventmachine'&lt;/span&gt;
&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'em-http-request'&lt;/span&gt;

&lt;span class="no"&gt;EM&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="no"&gt;Fiber&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;fb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Fiber&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;
    &lt;span class="n"&gt;http&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;EM&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;HttpRequest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'http://google.com/'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="ss"&gt;:query&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;'keyname'&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;'value'&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;errback&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;fb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resume&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;fb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resume&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;# suspend the fiber&lt;/span&gt;
    &lt;span class="no"&gt;Fiber&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;yield&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;
      &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s1"&gt;'An error occured, damn !'&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
      &lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;response_header&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;
      &lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;response_header&lt;/span&gt;
      &lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="no"&gt;EM&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resume&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;See what we did ? The program execution is now linear in the fiber, this code may run a little slower
than the asynchronous code I never did any serious benchmarks but the program is so much easier to
write this way that you will see immediate gains right away !  &lt;/p&gt;

&lt;p&gt;Note that the same can be done with threads&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'eventmachine'&lt;/span&gt;
&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'em-http-request'&lt;/span&gt;

&lt;span class="no"&gt;EM&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="no"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;th&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;
    &lt;span class="n"&gt;http&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;EM&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;HttpRequest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'http://google.com/'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="ss"&gt;:query&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;'keyname'&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;'value'&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;errback&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;th&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wakeup&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;th&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wakeup&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;# suspend the thread until explicit&lt;/span&gt;
    &lt;span class="c1"&gt;# wakeup&lt;/span&gt;
    &lt;span class="nb"&gt;sleep&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;
      &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s1"&gt;'An error occured, damn !'&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
      &lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;response_header&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;
      &lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;response_header&lt;/span&gt;
      &lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="no"&gt;EM&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;Fiber have another limitation though, they only have access to a limited stack size (4Kb in 1.9.2), while
you may use fibers without even noticing there is a catch: rails 3.1 which hit stable release recently can hit the boundaries of a fiber stack (see my &lt;a href="https://github.com/schmurfy/assets_crash"&gt;Rails 3.1 test application&lt;/a&gt;) resulting in a stack overflow error and the sad thing is that there nothing you can really do about this if you are not running your own server with a modified ruby interpreter extending the stack.&lt;/p&gt;

&lt;p&gt;A last example to show you how to do a sleep in an EventMachine fibered application:&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'fiber'&lt;/span&gt;
&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'eventmachine'&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;em_sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;fb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Fiber&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;
  &lt;span class="no"&gt;EM&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;add_timer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="n"&gt;fb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resume&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="no"&gt;Fiber&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;yield&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="no"&gt;EM&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;fb1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Fiber&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;"[Fiber 1] Started"&lt;/span&gt;
    &lt;span class="n"&gt;em_sleep&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;"[Fiber 1] Completed"&lt;/span&gt;
    &lt;span class="no"&gt;EM&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="n"&gt;fb2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Fiber&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;times&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;"[Fiber 2] tick &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="n"&gt;fb1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resume&lt;/span&gt;
  &lt;span class="n"&gt;fb2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resume&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;And here is the output:&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;[Fiber 1] Started
[Fiber 2] tick 0
[...]
[Fiber 2] tick 9
[Fiber 1] Completed
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;One last thing to know about fibers is that you can only one running as I already said but this limitation is per thread so you could have more fibers running but I see little use fot this case since you get get back to the same problems you would have with threads.&lt;/p&gt;

&lt;h2&gt;My experience in this field&lt;/h2&gt;

&lt;p&gt;I designed and implemented the core and network library of my current company's ruby servers,
these servers form a telecommunication platform and interface themselves with an heavy client
on user's computers as well as an Asterisk server, only one out of now 4/5 application servers is
a Ruby On Rails application the others are headless EventMachine servers communicating with each other.&lt;/p&gt;

&lt;p&gt;When development started ruby 1.9 was not yet released and so I started the work on 1.8 with threads
and then later switched to 1.9 + fibers to get away from the thread concurrency hell, our productivity
raised by a great factor and the overall performances too (faster queries) but ruby 1.9 by itself
is faster than 1.8 so both implementations cannot be fairly compared.&lt;/p&gt;

&lt;h2&gt;Interesting links&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://oldmoe.blogspot.com/2008/08/ruby-fibers-vs-ruby-threads.html"&gt;Threads vs Fibers resources usage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/igrigorik/em-synchrony" title="A set of helpers to work witi fibers"&gt;em-synchrony&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/eventmachine/eventmachine"&gt;EventMachine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
  </entry>
  <entry>
    <id>tag:schmurfy.github.com,2011-08-12:/2011/08/12/building_rack_middleware_with_sinatra.html</id>
    <title type="html">Building a Rack Middleware with sinatra</title>
    <published>2011-08-12T12:00:00Z</published>
    <updated>2011-08-12T12:00:00Z</updated>
    <link rel="alternate" href="http://schmurfy.github.com/2011/08/12/building_rack_middleware_with_sinatra.html"/>
    <content type="html">&lt;p&gt;I recently had the need to separate some logic from my main web application, after thinking
about it for a while (months actually) I finally got an illumination: what about rack ?&lt;br&gt;
After a quick test aside of my project I confirmed that building a rack middleware is really easy
( even easier that I thought ), this article is a quick tutorial to build a simple middleware.&lt;/p&gt;

&lt;h2&gt;What is rack ?&lt;/h2&gt;

&lt;p&gt;Rack is a library used in the Ruby to standardize the interactions between the different frameworks
we have and the web server themselves, thanks to Rack we can now build part of an application in
sinatra, another in rails, etc...&lt;br&gt;
Rack is a really nice piece of software but I doubt many out there really used it directly,
I knew it for quite a long time now but never really felt the need to dig in it.&lt;/p&gt;

&lt;p&gt;You can learn more about Rack &lt;a href="http://rack.rubyforge.org/" title="here"&gt;rack&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Our middleware&lt;/h2&gt;

&lt;p&gt;The middleware will simply serve an url with sinatra, I consider this simple enough
to get anyone interested started, based on this you can do nearly anything.&lt;br&gt;
The middleware will also accept parameters since I had to do some search to found out
how to do it.&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'rack'&lt;/span&gt;
&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'sinatra/base'&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AboutApp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;Sinatra&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;initialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="vi"&gt;@name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="s1"&gt;'/about'&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="s2"&gt;"Hello, my name is &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="vi"&gt;@str&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt; !"&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;And here is a config.ru file showing how to use it:&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'about_app'&lt;/span&gt;

&lt;span class="c1"&gt;# this class will act as our main application&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyApp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;Sinatra&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
  &lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="s1"&gt;'/test'&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="s2"&gt;"Test it yourself !"&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;


&lt;span class="n"&gt;use&lt;/span&gt; &lt;span class="no"&gt;AboutApp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:name&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s2"&gt;"Julien"&lt;/span&gt;
&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="no"&gt;MyApp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;And that is really all you need, now you can run your application with any rack compliant
web server which basically means you can run it on every web server supporting ruby ;)&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;unicorn
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;</content>
  </entry>
  <entry>
    <id>tag:schmurfy.github.com,2011-06-04:/2011/06/04/doing_things_differently_erlang.html</id>
    <title type="html">Doing things differently: Erlang</title>
    <published>2011-06-04T12:00:00Z</published>
    <updated>2011-06-04T12:00:00Z</updated>
    <link rel="alternate" href="http://schmurfy.github.com/2011/06/04/doing_things_differently_erlang.html"/>
    <content type="html">&lt;p&gt;Since I discovered RabbitMQ I kept an eye on Erlang but never looked past what is at first look an
horrible syntax.
I recently watched some presentations and read more about it to the point where I decided to take a
dive: I started reading tutorials and even bought two books, with that I was ready to start.&lt;/p&gt;

&lt;p&gt;I was never a fan of writing useless test applications which will end up in the trash right when you
finish it, what I do instead is that I always have a folder full of what would be best described
as small tests and the way I use this is every time I am not 100% sure of how to do something or
I do not know how to do it at all I start a new file (or reopen an existing one) and start a
minimal application which is usually 5 to 10 lines.&lt;/p&gt;

&lt;p&gt;I do this in ruby a lot and the nature of the language itself really makes it easy, see for yourself:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;create a new document in textmate (Apple + N)&lt;/li&gt;
&lt;li&gt;write code&lt;/li&gt;
&lt;li&gt;run it (Apple + R)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;While it is a little harder in Erlang I still use the same process which do wonders for me.&lt;/p&gt;

&lt;p&gt;So, aside from these tests I still needed a real project to work on, luckily I had one in stock:
I wanted to build a monitoring server similar to what collectd does but I wanted to try a different
approach and I kept this ideas for months since I had troubles deciding which language I wanted
to write it in.&lt;br&gt;
I will not speak about this application here but the project is already started and the basic
parts are working (the project is on my github account and is named collector if you want to
check it out).&lt;/p&gt;

&lt;p&gt;The goal here is not to make another tutorial, there are enough already on the web, what I will
do now is give you an overview of erlang features and you knowns, maybe makes you want to
know more about it.&lt;/p&gt;

&lt;p&gt;The way Erlang is built is really different from what I used until now, the main difference is obviously
the language itself but there are concepts built into Erlang which are too a great change, the syntax
is similar to prolog and knowing prolog surely helped me understand the erlang syntax faster.&lt;/p&gt;

&lt;p&gt;We will now see some of the specific features of Erlang.&lt;/p&gt;

&lt;h2&gt;Processes&lt;/h2&gt;

&lt;p&gt;In Erlang everything is run in what is called a process, this was really disturbing at first because
the "process" term in Erlang have really nothing to do with system processes and unlike them you can
have thousands or even millions of Erlang processes running judging by some articles/presentations I saw.&lt;br&gt;
I did not dug that too much but Erlang process seems to be code blocks distributed on a poll of threads.&lt;/p&gt;

&lt;p&gt;You use them like you would use threads in C/Java/Ruby except they are not threads.&lt;/p&gt;

&lt;h2&gt;Actor model&lt;/h2&gt;

&lt;p&gt;Each Erlang process has only one way to communicate with the others (that is not entirely true but
let's assume it is for now) and that is by passing a message to another process.&lt;br&gt;
That is a powerful model which is part of the language, I will speak more about it later.&lt;/p&gt;

&lt;h2&gt;Virtual Machine&lt;/h2&gt;

&lt;p&gt;That is the first time I see what we call a virtual machine looks like an actual virtual machine !
In Erlang your can run more than one application on a given vm or even connect to it to run
commands on a live system.&lt;/p&gt;

&lt;p&gt;Each running vm is called a node, you can connect multiple nodes to create a network which nearly acts
like a single computer making concurrent programming part of the language (both for multiple cpu cores
and multiple machines) and not something you have to specifically think about.&lt;/p&gt;

&lt;h2&gt;Immutability&lt;/h2&gt;

&lt;p&gt;That is another disturbing things when you first try to understand the language: once a "variable"
(they are not really variable since they cannot change) is assigned a value you cannot assign
another value to it. This really looks like a limitation at first but when used with pattern
matching it is in fact really powerful.&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;fail&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
  &lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="c"&gt;% error !&lt;/span&gt;

&lt;span class="nf"&gt;work&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
  &lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nv"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="c"&gt;% it works&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;h2&gt;Pattern matching&lt;/h2&gt;

&lt;p&gt;It is quite hard to wrap your mind around this one when not used to it but once you start
understanding it you can really appreciates it.&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;Result&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;mod&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;do_something&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
  &lt;span class="nv"&gt;Result&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;This piece of code looks pretty simple but what happens behind is that the function do_something
has to return a tuple (similar to a list but used to group things together, sort of a C structure
or an object) and the first element has to be "ok" (which is an atom here, they are similar to the ruby
symbols).&lt;/p&gt;

&lt;p&gt;This means that if the function does not return a tuple or if the tuple returned does not has
ok as its first value this code will raise an error and crash.&lt;/p&gt;

&lt;p&gt;As A C/Java/Ruby developer it is frightening when you realize that the process can crash anywhere
and our reflex would be to test if an error occurred but this is not how it works in Erlang
(C is especially horrible with the requirement to test the return
value of EACH function you call which is a huge waste of time).&lt;/p&gt;

&lt;h2&gt;Error Handling strategy&lt;/h2&gt;

&lt;p&gt;In Erlang all your work is separated in processes, as we saw there may be a lot of them each
doing their work and optionally dying when finished, this is how you create a process in Erlang:&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
  &lt;span class="nb"&gt;spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;do_something&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;In the previous code the function do_something() will be executed in a separate process from
the start function and the start function will end. But there is another way to start a process !&lt;br&gt;
If instead of using spawn you use spawn_link the process you create will be linked to the current one
and if an error occurs in the spawned process a message will be sent to this process telling it
that the process exited with the reason as an argument (which may just be that it finished its work but it may
also be that an error occured).&lt;/p&gt;

&lt;p&gt;The way you handle errors in erlang is exactly that, instead of trying to handle everything
that could go wrong with your code you just write for the better and separate your code in
different logical parts, then you add a supervisor which is simply a process monitoring the other
processes and which will restart them on error (if you ask it to).&lt;/p&gt;

&lt;p&gt;That is something I really do appreciate, each time I write C code it really makes me sad
having to test everything... Not only it slows me down when writing code but it create
a huge amount of code when in fact your code do not do that much.&lt;/p&gt;

&lt;p&gt;Let's take a real world use case: You want to build a TCP Server, here is what you might write
in C&lt;br&gt;
(there is more function calls in C but that is not the point here):&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(...);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;
      &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...);&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Hello !"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// handle error&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// handle the error&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// handle the error&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;And in Erlang:&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;Port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;Listen&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;gen_tcp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;Port&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[])&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;Socket&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;gen_tcp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;Listen&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
  &lt;span class="nn"&gt;gen_tcp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;Socket&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Hello !"&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;In a real application the start function will be ran under a supervisor, if the listen of accept
call fails the process will die and will be restarted ! Coding this way is really nice, you can
concentrate on your real goal instead of keeping in mind the worst possible things that could happen.&lt;/p&gt;

&lt;p&gt;I do not say you can completely ignore them but I found than when coding this way you can put them
aside.&lt;/p&gt;

&lt;h2&gt;Distributed computing&lt;/h2&gt;

&lt;p&gt;The last thing I want to mention is how easy an application can be distributed across cpu cores
or even physical machines, the vm knowns how to uses all the cpu on the server running it and
you can link multiple virtual machines together to form a network of nodes (each node being
an erlang vm running on a different computer) in which a process can be spawned on any node.&lt;/p&gt;

&lt;p&gt;Since spawn_link works from a node to another too you can have supervisors monitoring process on
multiple nodes allowing you to easily failover case where a process is spawned on node2 to replace
the one on node2 you just lost because the machine is down.&lt;/p&gt;

&lt;p&gt;This was just was an overview of the features of this language, if you want to lean more about it
here is some resources which helped me learning it:&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.infoq.com/presentations/joe-armstrong-erlang-qcon08"&gt;Presentation from Joe Armstrong, one of Erlang creators&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The two books I read after finding good reviews about them:&lt;br&gt;&lt;a href="http://pragprog.com/titles/jaerlang/programming-erlang"&gt;Programming Erlang written by Joe Armstrong&lt;/a&gt;&lt;br&gt;&lt;a href="http://oreilly.com/catalog/9780596518189"&gt;Erlang from O'reilly&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Both books obviously have common parts but the second cover things that were only mentionned in the first one,
If you should only buy one I consider Programming Erlang.&lt;/p&gt;

&lt;p&gt;And lastly here is a nice website with tutorials:&lt;br&gt;&lt;a href="http://learnyousomeerlang.com/content"&gt;learn you some Erlang&lt;/a&gt;&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>tag:schmurfy.github.com,2011-05-19:/2011/05/07/ruby_application_monitoring.html</id>
    <title type="html">Ruby Application Monitoring</title>
    <published>2011-05-19T20:30:00Z</published>
    <updated>2011-05-19T20:30:00Z</updated>
    <link rel="alternate" href="http://schmurfy.github.com/2011/05/07/ruby_application_monitoring.html"/>
    <content type="html">&lt;p&gt;When any of your applications starts to really fly by themselves you are bound to reach a
point where you want/need to know what happen inside it and translate that into graphs
you can show and monitor to check the health of the system.&lt;/p&gt;

&lt;p&gt;Such a system include many parts that must work together to bring you the data you want
and/or want to show and that is where I faced my first wall.&lt;/p&gt;

&lt;h2&gt;What are those parts ?&lt;/h2&gt;

&lt;h3&gt;Producer&lt;/h3&gt;

&lt;p&gt;Your applications can produce data you want to store and view immediately or later,
a general purpose probe can also extract useful metrics from a physical server like
the cpu usage, the load, memory, etc...&lt;br&gt;&lt;/p&gt;

&lt;h3&gt;Aggregator / Router&lt;/h3&gt;

&lt;p&gt;This node is the one receiving the data and deciding what to do with them, whether
it will be stored on a local disk in rrd or send on the network to another application
and whether to use the data as is or to transform them before.&lt;br&gt;&lt;/p&gt;

&lt;h3&gt;Storage Engine&lt;/h3&gt;

&lt;p&gt;I decided to separate this one but most of the time it will be a subpart of the
Aggregator / Router. The storage will determine how and where your data will be
stored, most of the time it will be rrd since it works and there are not real
alternatives out there.&lt;br&gt;
While the rrd format itself is nice I am not really too fond of the rrd library
itself, the api is really ugly and always force me to do things I do not want
to do whenever I need to work with it.&lt;/p&gt;

&lt;h3&gt;Graph drawer&lt;/h3&gt;

&lt;p&gt;That is the last part and will surely be the most important since whatever
energy/dedication you put in setting up the other parts it is that one anyone
will face and that is also one of my biggest problem...&lt;/p&gt;

&lt;h2&gt;Choosing the right parts&lt;/h2&gt;

&lt;p&gt;There are some beast out there that are heavily used when you start speaking about monitoring
you are nearly forced to hit them (or get it by them), the name I hear the most are:
Nagios, Munin, Cacti, MRTG, SmokePing.&lt;/p&gt;

&lt;p&gt;There a multiple problems for me with those systems, the first one is that some
are more or less focused on a specific need (like SmokePing) and making them play
together can be really "fun", the kind of fun nobody wants.&lt;br&gt;
The other problem I faced is that they tend to want control over the whole monitoring system,
they want you to use their producers module, their graph drawer, their router and if
you want to step aside and change one part your are doomed.&lt;br&gt;
It may have changed since last time I did a check but I highly doubt it.&lt;/p&gt;

&lt;p&gt;I worked with some of those in the past but never really liked them so when I
faced again the need to collect metrics from different applications/languages
as well as server's metrics I tried to find something else.&lt;/p&gt;

&lt;h3&gt;The SmokePing case&lt;/h3&gt;

&lt;p&gt;Before I started working on a monitoring solution for a work project I am currently
on there was previously SmokePing set up, I may be heavily biased on it
because of my first impression but what first impression it made !&lt;/p&gt;

&lt;p&gt;The first things I noticed when looking at it was that the server part was slow as hell
and was taking a more than noticeable part of the cpu (I honestly do not
remember how much but it was certainly not invisible on the machine speaking
of resources) so I checked its producer counterpart which is on an embedded system
(Soekris hardware) and here too the daemon was not invisible at all !&lt;/p&gt;

&lt;p&gt;The last thing that crushed that beast for me is that loading a page with graphs on
it was slow too and caused cpu spikes, perfect !&lt;/p&gt;

&lt;p&gt;It is perfectly possible that smokeping was badly installed and would work
far better in normal conditions (that said I am not too sure about the producer part)
but seriously what can you do with such bright first impression ?&lt;/p&gt;

&lt;h3&gt;Enter Collectd&lt;/h3&gt;

&lt;p&gt;While looking for a decent Aggregator I came upon collectd which I never saw
before and does a really great job at dispatching metrics.&lt;/p&gt;

&lt;p&gt;Collectd is a modular application with modules falling in two categories:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;readers: these plugins receive data from somewhere or extract it (ex: 
network, shell command, /proc file, etc...)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;writers: these plugins will output the data somewhere (ex: network again,
rrdtool, rrdcached, database, etc...)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Collectd do a really nice job but some parts are hard to use and not really
designed for usability, the best example I have is the filter system,
Collectd comes with a really powerful filter subsystem which lets you
update/add/delete fields of the collectd "messages" or the whole messages.&lt;/p&gt;

&lt;p&gt;Sadly this filter subsystem has one of the worst configuration interface
I have seen until now, see for yourself (and this one is a simple one):&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;Rule&lt;/span&gt; &lt;span class="s"&gt;"ping_server1"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;Match&lt;/span&gt; &lt;span class="s"&gt;"regex"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nb"&gt;Plugin&lt;/span&gt; &lt;span class="s2"&gt;"^ping$"&lt;/span&gt;
    &lt;span class="nb"&gt;TypeInstance&lt;/span&gt; &lt;span class="s2"&gt;"^1.2.3.4$"&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/Match&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;Target&lt;/span&gt; &lt;span class="s"&gt;"replace"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nb"&gt;TypeInstance&lt;/span&gt; &lt;span class="s2"&gt;"1.2.3.4"&lt;/span&gt; &lt;span class="s2"&gt;"server1"&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/Target&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/Rule&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;This one is pretty straight forward but all this text is just to
replace a string with another...&lt;/p&gt;

&lt;p&gt;In another language this could become:&lt;/p&gt;

&lt;pre&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_instance&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"1.2.3.4"&lt;/span&gt;
  &lt;span class="nb"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type_instance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"server1"&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;Just imagine what a complex flow would look with the xml like
syntax :/&lt;/p&gt;

&lt;p&gt;While I have some issues with collectd I am currently using it on
production servers as well as embedded systems and it works well.&lt;/p&gt;

&lt;h3&gt;The producers&lt;/h3&gt;

&lt;p&gt;Sending your own counters to collectd is not really hard, the network
plugin of collectd use a clearly defined and simple binary format served
over UDP and many libraries exist out there for different languages to
generate those packets and send them to collectd.&lt;/p&gt;

&lt;h3&gt;Serving graphs&lt;/h3&gt;

&lt;p&gt;The only part left is the user interface used to navigate and generate
the graphs from all these data we collected and that is where the real
problem arise... Since many existing systems want control over the
whole data collection chains you cannot easily integrate data from
somewhere else.&lt;/p&gt;

&lt;p&gt;My quest was to find a tool doing a really simple thing (at least
I thought it was): draw graphs from rrd file and serve them to the
clients while staying nearly invisible on the server resource wise.&lt;/p&gt;

&lt;p&gt;Do you know one ? Because I could really use some names here.&lt;/p&gt;

&lt;p&gt;I ended up coding my own modest graph drawer but that is just a small
part of what I need. WHat I have now is a sinatra application
which uses the client itself to compute the graphs with some
javascript around the excellent jquery library: &lt;a href="http://code.google.com/p/flot/"&gt;flot&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since the clients are drawing the graphs the server is really
not doing much, only extracting data from the rrd and formatting
them in json which is really nice.&lt;/p&gt;

&lt;h2&gt;Current State&lt;/h2&gt;

&lt;p&gt;I have a working stack for now, I am not completly happy with it
but at least I have control over the parts and except for the grapher
I am just using existing application/library so I did not have
to write any code.&lt;/p&gt;

&lt;p&gt;I am still searching for a better solutions and working on some
projects which may help but that will be for another time :)&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>tag:schmurfy.github.com,2011-05-06:/2011/05/06/create_your_github_user_page_with_nanoc.html</id>
    <title type="html">Create your Github user page with nanoc</title>
    <published>2011-05-06T13:00:00Z</published>
    <updated>2011-05-06T13:00:00Z</updated>
    <link rel="alternate" href="http://schmurfy.github.com/2011/05/06/create_your_github_user_page_with_nanoc.html"/>
    <content type="html">&lt;p&gt;I finally took the time to build myself a fully featured blog and start writing down things that floats
in my head both for me and for anyone it can help.&lt;br&gt;
I was sure of one thing: I wanted a static blog, I do not want having to learn to use a complex
admin interface that would certainly not fit me needs and end with a fork to maintain...&lt;br&gt;
Another reason is that I prefer to edit posts in my favorite text editor (that would be textmate)
than editing it online with a pale copy of a real text editor.&lt;/p&gt;

&lt;p&gt;I was looking at github user pages for quite some time but the quick look I gave to jekyll did not convinced
me so here is an alternative way to build your github user page without using jekyll.&lt;/p&gt;

&lt;h2&gt;What we will use&lt;/h2&gt;

&lt;p&gt;Nanoc is a powerful ruby static website generator, I already used it before for a personal documentation
repository (something like my personal knowledge database) and tested the alternatives before settling on
it so there was little to no reason to switch except if a new alternative with more features had appeared
but jekyll is certainly not that.&lt;/p&gt;

&lt;p&gt;So nanoc it is !&lt;br&gt;&lt;/p&gt;

&lt;p&gt;This article will not teach you how to use nanoc by itself, if you are interested in it you can check:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://nanoc.stoneship.org/"&gt;The Official Website&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/mgutz/nanoc3_blog"&gt;The template I based mine on&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/schmurfy/schmurfy.github.com/tree/source"&gt;And obviously my template&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;How github user's pages work&lt;/h2&gt;

&lt;p&gt;The user page system is really simple to use and works really well, what they did is that if you create a repository
with a special name (&lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt;.github.com) then anything pushed in the master branch will be available at the
same address, pretty neat and effective !&lt;/p&gt;

&lt;p&gt;The master branch can either contains raw html/css/... documents or a jekyll project which will be
used to generate the html so in our case we want to push the resulting output from nanoc.&lt;/p&gt;

&lt;h2&gt;Workspace organization&lt;/h2&gt;

&lt;p&gt;What I did is use another branch than master to host the actual nanoc application and push the
resulting html in the master branch, here is how I organized my workspace:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;root &lt;span class="o"&gt;[&lt;/span&gt; -&amp;gt; &lt;span class="s2"&gt;"source"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
  |- content &lt;span class="o"&gt;(&lt;/span&gt;nanoc templates&lt;span class="o"&gt;)&lt;/span&gt;
  |- layouts &lt;span class="o"&gt;(&lt;/span&gt;nanoc layouts&lt;span class="o"&gt;)&lt;/span&gt;
  |- lib &lt;span class="o"&gt;(&lt;/span&gt;ruby files extending nanoc&lt;span class="o"&gt;)&lt;/span&gt;
  |- output &lt;span class="o"&gt;[&lt;/span&gt; -&amp;gt; &lt;span class="s2"&gt;"master"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;root will contains a working copy of our git repository pointing at the source branch and
output will contains a working copy of the same repository pointing at the master branch,
the tricky part here is that these two branches need to be completly separated,
we wil now see how (there is a guide on github to do this too).&lt;/p&gt;

&lt;h2&gt;Setting up things&lt;/h2&gt;

&lt;p&gt;First we need to initialize the repository, just use your root folder for this
("$" is the prompt here):&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# initialize the local repository&lt;/span&gt;
  &lt;span class="nv"&gt;$ &lt;/span&gt;git init
&lt;span class="c"&gt;# commits your files&lt;/span&gt;
  &lt;span class="nv"&gt;$ &lt;/span&gt;git add .
  &lt;span class="nv"&gt;$ &lt;/span&gt;git ci -m &lt;span class="s2"&gt;"init"&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we have a master branch containing our site's source which is not yet what we
want, so we will now rename this branch and push it to the remote:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# rename our master branch&lt;/span&gt;
  &lt;span class="nv"&gt;$ &lt;/span&gt;git br -m master &lt;span class="nb"&gt;source&lt;/span&gt;
&lt;span class="c"&gt;# add your github repository as origin&lt;/span&gt;
  &lt;span class="nv"&gt;$ &lt;/span&gt;git add origin git@github.com:&lt;span class="o"&gt;[&lt;/span&gt;user&lt;span class="o"&gt;]&lt;/span&gt;/&lt;span class="o"&gt;[&lt;/span&gt;user&lt;span class="o"&gt;]&lt;/span&gt;.github.com.git
&lt;span class="c"&gt;# push to the remote repository and set the master local branch to&lt;/span&gt;
&lt;span class="c"&gt;# track origin/master&lt;/span&gt;
  &lt;span class="nv"&gt;$ &lt;/span&gt;git push -u origin master
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We have a repository with only one branch: source, now we can create the master branch.&lt;br&gt;
remove the output folder if it exists (rm -rf output) and do this:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# fetch a working copy of your repository&lt;/span&gt;
  &lt;span class="nv"&gt;$ &lt;/span&gt;git clone git@github.com:&lt;span class="o"&gt;[&lt;/span&gt;user&lt;span class="o"&gt;]&lt;/span&gt;/&lt;span class="o"&gt;[&lt;/span&gt;user&lt;span class="o"&gt;]&lt;/span&gt;.github.com.git output
  &lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;output
&lt;span class="c"&gt;# create the isolated branch&lt;/span&gt;
  &lt;span class="nv"&gt;$ &lt;/span&gt;git symbolic-ref HEAD refs/heads/master
  &lt;span class="nv"&gt;$ &lt;/span&gt;rm .git/index
  &lt;span class="nv"&gt;$ &lt;/span&gt;git clean -fdx
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You should now have your master branch ready, just generate your nanoc output
(nanoc3 co in the root folder) and commit &amp;amp; push your files and your site should
appears shortly.&lt;/p&gt;

&lt;p&gt;(Actually it took a second commit for me for the site to effectively appears)&lt;/p&gt;

&lt;p&gt;One thing allowing this setup to work is that nanoc do not delete the output folder
when rebuilding the site, it justs overwrite existing files.&lt;/p&gt;</content>
  </entry>
</feed>
